# secret.yaml — Kubernetes Secret for database credentials.
#
# This chart support three levels of secret management.
# The right choice depends on the environment:
#
#   Level 1 — Local development (current setup)
#     Credentials are passed via values-local.yaml (gitignored) or
#     helm install --set.
#     Run `make helm-secrets` to generate values-local.yaml from .env.
#
#   Level 2 — GitOps
#     Sealed Secrets encrypts the Secret with the cluster's public key.
#     The encrypted version is safe to commit, only the target cluster
#     can decrypt it.
#     Tool: https://github.com/bitnami-labs/sealed-secrets
#     Command: kubeseal --format yaml < secret.yaml > sealed-secret.yaml
#
#   Level 3 — External Secrets Operator
#     External Secrets Operator syncs credentials from a vault
#     (HashiCorp Vault, AWS Secrets Manager, GCP Secret Manager).
#     Credentials never exist in Git at all, not even encrypted.
#     Set postgresql.auth.existingSecret to point to the ExternalSecret.
#     Tool: https://external-secrets.io
#
# To move from Level 1 to Level 2 or 3, the only change needed is in
# values.yaml, the rest of the Helm templates stay identical.

{{- if not .Values.postgresql.auth.existingSecret }}
apiVersion: v1
kind: Secret
metadata:
  name: {{ .Release.Name }}-db-credentials
  labels:
    app: {{ .Release.Name }}
    component: db-credentials
# stringData accepts plain text; Kubernetes stores it base64-encoded.
# Inspect with: kubectl get secret snapenv-db-credentials -o yaml
type: Opaque
stringData:
  POSTGRES_USER: {{ .Values.postgresql.auth.username | quote }}
  POSTGRES_PASSWORD: {{ .Values.postgresql.auth.password | quote }}
  POSTGRES_DB: {{ .Values.postgresql.auth.database | quote }}
{{- end }}
